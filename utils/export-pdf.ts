import jsPDF from 'jspdf';

// --- ç±»å‹å®šä¹‰ ---
interface ExportMeta {
  projectName: string;
  author: string;
  notes: string;
}

// --- ğŸŸ¢ æ–°å¢ï¼šç¿»è¯‘å·¥å…·å‡½æ•° ---
const translateShot = (shot: string) => {
    if (!shot) return "-";
    const upper = shot.toUpperCase();
    if (upper.includes('EXTREME WIDE') || upper.includes('EXTREME LONG')) return 'å¤§è¿œæ™¯';
    if (upper.includes('WIDE') || upper.includes('LONG')) return 'å…¨æ™¯';
    if (upper.includes('FULL')) return 'å…¨èº«';
    if (upper.includes('MID') || upper.includes('MEDIUM')) return 'ä¸­æ™¯';
    if (upper.includes('EXTREME CLOSE')) return 'å¤§ç‰¹å†™';
    if (upper.includes('CLOSE')) return 'ç‰¹å†™';
    return shot;
};

// --- å·¥å…·å‡½æ•° ---

// 1. ç½‘ç»œå›¾ç‰‡è½¬ Base64
const getBase64ImageFromURL = (url: string): Promise<string> => {
  return new Promise((resolve, reject) => {
    const img = new Image();
    img.crossOrigin = 'Anonymous';
    img.src = url;
    img.onload = () => {
      const canvas = document.createElement('canvas');
      canvas.width = img.width;
      canvas.height = img.height;
      const ctx = canvas.getContext('2d');
      if (!ctx) return reject('Canvas error');
      ctx.drawImage(img, 0, 0);
      const dataURL = canvas.toDataURL('image/jpeg', 0.8);
      resolve(dataURL);
    };
    img.onerror = (error) => reject(error);
  });
};

// 2. åŠ è½½ä¸­æ–‡å­—ä½“ (å¿…é¡»ä¿ç•™ï¼Œå¦åˆ™ä¸­æ–‡ä¹±ç )
const loadChineseFont = async (doc: jsPDF) => {
  try {
    const fontUrl = `/fonts/custom-font.ttf`; // ç¡®ä¿ public/fonts ä¸‹æœ‰æ­¤æ–‡ä»¶
    console.log(`[PDF] æ­£åœ¨åŠ è½½å­—ä½“: ${fontUrl}`);
    const response = await fetch(fontUrl);
    if (!response.ok) throw new Error(`å­—ä½“æ–‡ä»¶ç¼ºå¤±`);
    const buffer = await response.arrayBuffer();
    
    let binary = '';
    const bytes = new Uint8Array(buffer);
    const len = bytes.byteLength;
    for (let i = 0; i < len; i++) { binary += String.fromCharCode(bytes[i]); }
    const base64Font = btoa(binary);

    doc.addFileToVFS("CustomFont.ttf", base64Font);
    doc.addFont("CustomFont.ttf", "CustomFont", "normal");
    doc.setFont("CustomFont");
    return true;
  } catch (e) {
    console.error("[PDF] å­—ä½“åŠ è½½å¤±è´¥:", e);
    // å›é€€å­—ä½“ï¼Œè™½ç„¶ä¸æ”¯æŒä¸­æ–‡ä½†è‡³å°‘èƒ½æ˜¾ç¤ºè‹±æ–‡
    doc.setFont("helvetica");
    return false;
  }
};

// 3. ç»˜åˆ¶é¡µçœ‰é¡µè„š
const drawHeaderFooter = (doc: jsPDF, pageNo: number, meta: ExportMeta, pageWidth: number, pageHeight: number) => {
    // é¡µçœ‰èƒŒæ™¯
    doc.setFillColor(20, 20, 20);
    doc.rect(0, 0, pageWidth, 20, 'F');
    
    // é¡µçœ‰æ–‡å­— (ğŸŸ¢ æ±‰åŒ–)
    doc.setTextColor(255, 255, 255);
    doc.setFontSize(10);
    doc.text("AI.TUBE STUDIO | åˆ¶ä½œé€šå‘Šå• (SOP)", 10, 13);
    doc.text(meta.projectName.slice(0, 40), pageWidth - 10, 13, { align: 'right' });

    // é¡µè„šçº¿
    doc.setDrawColor(200);
    doc.line(10, pageHeight - 15, pageWidth - 10, pageHeight - 15);
    
    // é¡µè„šæ–‡å­—
    doc.setTextColor(100);
    doc.setFontSize(8);
    const authorText = meta.author ? `å¯¼æ¼”: ${meta.author} | ` : "";
    doc.text(`${authorText}Generated by CineFlow AI`, 10, pageHeight - 10);
    doc.text(`ç¬¬ ${pageNo} é¡µ`, pageWidth - 10, pageHeight - 10, { align: 'right' });
    
    doc.setTextColor(0);
};

// --- ä¸»å¯¼å‡ºå‡½æ•° ---

export const exportStoryboardPDF = async (
  meta: ExportMeta,
  panels: any[]
) => {
  const doc = new jsPDF('p', 'mm', 'a4');
  await loadChineseFont(doc);

  const pageWidth = doc.internal.pageSize.getWidth();
  const pageHeight = doc.internal.pageSize.getHeight();
  const margin = 15;
  const shotHeight = 110; 
  const imgWidth = 120;
  const imgHeight = 67.5; 
  
  // === 1. å°é¢é¡µ (Cover Sheet) ===
  doc.setFontSize(32);
  doc.text("SHOOTING SCRIPT", pageWidth / 2, 60, { align: 'center' });
  doc.text("æ‰§è¡Œè„šæœ¬ä¸åˆ†é•œè¡¨", pageWidth / 2, 75, { align: 'center' });

  // é¡¹ç›®ä¿¡æ¯æ¡†
  doc.setDrawColor(0);
  doc.setLineWidth(0.5);
  doc.rect(pageWidth / 2 - 70, 100, 140, 80);
  
  // ğŸŸ¢ æ±‰åŒ–å…ƒæ•°æ®æ ‡ç­¾
  doc.setFontSize(12);
  doc.text(`é¡¹ç›®åç§°: ${meta.projectName || "æœªå‘½åé¡¹ç›®"}`, pageWidth / 2, 115, { align: 'center' });
  doc.text(`å¯¼æ¼”/ä½œè€…: ${meta.author || "AI Creator"}`, pageWidth / 2, 125, { align: 'center' });
  doc.text(`ç”Ÿæˆæ—¥æœŸ: ${new Date().toLocaleDateString('zh-CN')}`, pageWidth / 2, 135, { align: 'center' });
  doc.text(`åˆ†é•œæ€»æ•°: ${panels.length}`, pageWidth / 2, 145, { align: 'center' });
  
  if (meta.notes) {
      doc.setFontSize(10);
      doc.setTextColor(100);
      const splitNotes = doc.splitTextToSize(`å¤‡æ³¨: ${meta.notes}`, 120);
      doc.text(splitNotes, pageWidth / 2, 160, { align: 'center' });
  }
  
  // åº•éƒ¨ Logo
  doc.setFontSize(14);
  doc.setTextColor(0);
  doc.text("AI.TUBE INC.", pageWidth / 2, 260, { align: 'center' });

  // === 2. å†…å®¹é¡µ ===
  let cursorY = 30;
  let pageNo = 1;
  
  const imagesBase64: Record<string, string> = {};
  for (const panel of panels) {
    if (panel.imageUrl) {
      try { imagesBase64[panel.id] = await getBase64ImageFromURL(panel.imageUrl); } catch (e) {}
    }
  }

  doc.addPage();
  doc.setFont("CustomFont"); 
  drawHeaderFooter(doc, pageNo, meta, pageWidth, pageHeight);

  panels.forEach((panel, index) => {
    if (cursorY + shotHeight > pageHeight - 20) {
      doc.addPage();
      pageNo++;
      doc.setFont("CustomFont");
      drawHeaderFooter(doc, pageNo, meta, pageWidth, pageHeight);
      cursorY = 30;
    }

    // é•œå¤´åºå·
    doc.setFillColor(0,0,0);
    doc.circle(margin + 8, cursorY + 8, 6, 'F');
    doc.setTextColor(255);
    doc.setFontSize(10);
    doc.text(`${index + 1}`, margin + 8, cursorY + 11.5, { align: 'center' });

    // å›¾ç‰‡
    if (imagesBase64[panel.id]) {
      doc.addImage(imagesBase64[panel.id], 'JPEG', margin + 20, cursorY, imgWidth, imgHeight);
    } else {
      doc.setFillColor(240, 240, 240);
      doc.rect(margin + 20, cursorY, imgWidth, imgHeight, 'F');
      doc.setTextColor(150);
      doc.text("ç­‰å¾…æ¸²æŸ“ (Waiting)", margin + 60, cursorY + 30); // ğŸŸ¢ æ±‰åŒ–
    }

    // å³ä¾§å‚æ•° (ğŸŸ¢ æ±‰åŒ–æ ‡ç­¾ + æ•°å€¼ç¿»è¯‘)
    const rightColX = margin + 20 + imgWidth + 5;
    doc.setTextColor(0);
    const params = [
        { label: "æ™¯åˆ« (SHOT)", value: translateShot(panel.shotType) }, // ç¿»è¯‘ Value
        { label: "ç¯å¢ƒ (ENV)", value: panel.environment || "-" },
        { label: "è§’è‰² (CHAR)", value: panel.characterIds && panel.characterIds.length > 0 ? "æœ‰" : "æ— " },
    ];
    params.forEach((p, i) => {
        doc.setFontSize(7);
        doc.setTextColor(120);
        doc.text(p.label, rightColX, cursorY + 5 + (i * 12));
        doc.setFontSize(9);
        doc.setTextColor(0);
        // æˆªæ–­è¿‡é•¿æ–‡å­—
        doc.text(p.value.slice(0, 10), rightColX, cursorY + 9 + (i * 12));
    });

    // ä¸‹æ–¹ Prompt
    const textStartY = cursorY + imgHeight + 8;
    doc.setFontSize(8);
    doc.setTextColor(100);
    doc.text("ç”»é¢æè¿° / ACTION:", margin, textStartY);
    
    doc.setFontSize(10);
    doc.setTextColor(0);
    const splitDesc = doc.splitTextToSize(panel.description || "", pageWidth - margin * 2);
    doc.text(splitDesc, margin, textStartY + 5);
    
    const descHeight = splitDesc.length * 5; 
    const promptY = textStartY + descHeight + 8;
    
    doc.setFillColor(245, 245, 245); 
    doc.rect(margin, promptY - 4, pageWidth - margin * 2, 18, 'F');

    doc.setFontSize(7);
    doc.setTextColor(100);
    doc.text("AI æç¤ºè¯ (PROMPT):", margin + 2, promptY);
    
    doc.setFontSize(8);
    doc.setTextColor(80);
    const rawPrompt = panel.prompt || "";
    const displayPrompt = rawPrompt.length > 250 ? rawPrompt.slice(0, 250) + "..." : rawPrompt;
    const splitPrompt = doc.splitTextToSize(displayPrompt, pageWidth - margin * 2 - 4);
    doc.text(splitPrompt, margin + 2, promptY + 4);

    doc.setDrawColor(200);
    doc.setLineWidth(0.5);
    doc.line(margin, cursorY + shotHeight - 5, pageWidth - margin, cursorY + shotHeight - 5);

    cursorY += shotHeight;
  });

  doc.save(`${meta.projectName.replace(/\s+/g, '_')}_é€šå‘Šå•.pdf`); // ğŸŸ¢ æ±‰åŒ–æ–‡ä»¶å
};